#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>

//int main()
//{
//	int a = 5 / 2;
//	printf("%d\n", a);
//	return 0;
//}

//int main()
//{
//	int a = 16;
//	//00000000000000000000000000010000
//	int b=a >> 1;
//	//00000000000000000000000000001000
//	//右移操作符
//	//算术右移：右边丢弃，左边补原符号位，就是>>
//	//逻辑右移：右边丢弃，左边补0
//	printf("%d\n", b);//8，对正整数有一个除二的效果
//	return 0;
//}

//int main()
//{
//	int a = -1;
//	//
//	//整数的二进制表示有原码、反码、补码
//	//储存到内存的是补码正数三码相同，负数的运算如下
//	//10000000000000000000000000000001：原码
//	//11111111111111111111111111111110：反码：原码符号位不变，其他位按位取反，得到反码
//	//11111111111111111111111111111111：补码：反码+1得到补码,即-1在内存的补码为32个1，反映在内存为十六进制8个f
//	//11111111111111111111111111111111：算术右移，即右边丢弃，左边补原符号位，发现还是-1的补码
//	//ff ff ff ff;内存以16进制表示，一个f为15，二进制为4个1，一共4*8=32位，即补码
//	//1111
//	//8421=15
//	int b = a >> 1;
//	//10000000000000000000000000001000
//	//右移操作符
//	//算术右移：右边丢弃，左边补原符号位，就是>>
//	//逻辑右移：右边丢弃，左边补0
//
//	printf("%d\n", b);//-1，由于-1除2是小数，因此向下取整还是-1
//	return 0;
//}

//int main()
//{
//	int a = 5;
//	//左移操作符
//	//左边丢弃，右边0，就是<<
//	//00000000000000000000000000000101
//	//00000000000000000000000000001010
//	int b = a << 1;对正整数有一个乘二的效果
//	printf("%d\n", b);
//	return 0;
//}

//int main()
//{
//	int a = -1;
//	//左移操作符
//	//左边丢弃，右边补0，就是<<
//	//10000000000000000000000000000001
//	//11111111111111111111111111111110
//	//11111111111111111111111111111111
//	//11111111111111111111111111111110
//	//看一下-2的补码
//	//10000000000000000000000000000010
//	//11111111111111111111111111111101
//	//11111111111111111111111111111110
//	//对于负整数，乘2效果也成立
//	int b = a << 1;
//	printf("%d\n", b);
//	return 0;
//}
//int main()
//{
//	int a = 2147483647;
//	//左移操作符
//	//左边丢弃，右边补0，就是<<
//	//01111111111111111111111111111111对于正整数，三码相同，a的补码是这个
//	//11111111111111111111111111111110左移后的补码与-2的补码相同
//	//看一下-2的补码
//	//10000000000000000000000000000010
//	//11111111111111111111111111111101
//	//11111111111111111111111111111110
//	//对于负整数，乘2效果也成立
//	int b = a << 1;
//	printf("%d\n", a);
//	printf("%d\n", b);//-2
//	return 0;
//}
//int main()
//{
//	int num1 = 12;
//	int num2 = 6;
//	printf("%d\n", num1 & num2);
//	printf("%d\n", num1 | num2);
//	printf("%d\n", num1 ^ num2);
//	return 0;
//}

//int main()//编写代码实现：求一个整数存储在内存中的二进制中1的个数。从123取各位数的数字这个例子得出思路
//{
//	int num = 10;
//	int count = 0;//计数
//	scanf("%d", &num);
//	while (num)
//	{
//		if (num % 2 == 1)
//			count++;
//		num = num / 2;
//	}
//	printf("二进制中1的个数 = %d\n", count);//对于-1出问题
//	return 0;
//}

//int main()
//{
//	int num = -1;
//	int i = 0;//num&1得到1，则num对应位数上一定是1；将这个1右移，充分按位与运算
//	int count = 0;//计数
//	for (i = 0; i<32; i++)
//	{
//		if (((num>>i)&1)==1)
//			count++;
//	}
//	printf("二进制中1的个数 = %d\n", count);
//	return 0;
//}

//int main()
//{
//	printf("%d\n", sizeof(int));
//	return 0;
//}

//int main()
//{
//	short s = 15;
//	int a = 10;
//	printf("%d\n", sizeof(s = a + 5));//sizeof里面的s=a+5并不会真正地赋值
//	printf("%d\n", sizeof s);
//	printf("%d\n", s);
//	return 0;
//
//}

//int main()
//{
//	int a = 11;
//	//int b = ~a;
//	a = a | (1 << 2);
//	//00000000000000000000000000001011
//	//00000000000000000000000000000100
//	//00000000000000000000000000001111
//	a = a&(~(a << 2));
//	//00000000000000000000000000001111
//	//11111111111111111111111111111011
//	//00000000000000000000000000001011
//	//逆回去
//	printf("%d\n",a);
//	return 0;
//}



//int main()
//{
//	int a = 10;
//	printf("%d\n", a++);//此处a的运算会进行赋值
//	printf("%d\n", a);
//	return 0;
//}

//int main()
//{
//	int a = (int)3.14;
//	printf("%d",a);//3
//	return 0;
//}

//void test1(int arr[])
//{
//	printf("%d\n", sizeof(arr));//(2)4
//}
//void test2(char ch[])
//{
//	printf("%d\n", sizeof(ch));//(4)4
//}
//int main()
//{
//	int arr[10] = { 0 };
//	char ch[10] = { 0 };
//	printf("%d\n", sizeof(arr));//(1)40
//	printf("%d\n", sizeof(ch));//(3)10
//	test1(arr);
//	test2(ch);
//	return 0;
//}

//int main()
//{
//	int i = 0, a = 1, b = 2, c = 3, d = 4;
//	//i = a++ && ++b && d++;//a为0，然后在运算后面的。因为判断为假，所以a++&&右边的运算都不进行，然后再对a本身进行++，相当于只对a加了1//1234
//	//i = a++ && ++b && d++;//若前面改为a为1，然后在运算后面的。因为判断为真，所以a++右边的运算都算数，//2335
//	//i = a++||++b||d++;//在a=1的情况下，由于a=1为真，所以a++||右边运算都不进行，只有a++进行了运算//2234
//	printf("a = %d\n b = %d\n c = %d\nd = %d\n", a, b, c, d);
//	return 0;
//}


//int main()
//{
//	int a = 3;
//	int b = 5;
//	b = (a > 5 ? 3 : -3);
//	printf("%d\n", b);
//	return 0;
//}

////代码1
//int a = 1;
//int b = 2;
//int c = (a>b, a = b + 10, a, b = a + 1);//逗号表达式
//c是多少// 0   12          12  13
//逗号表达式，从左向右依次执行。整个表达式的结果是最后一个表达式的结果。

//if (a = b + 1, c = a / 2, d > 0)
//判断之前，先进行前面的赋值运算


////代码3
//a = get_val();
//count_val(a);
//while (a > 0)
//{
//	//业务处理
//	a = get_val();
//	count_val(a);
//}
//如果使用逗号表达式，改写：
//while (a = get_val(), count_val(a), a>0)
//{
//	//业务处理
//}


//int arr[10];//创建数组
//arr[9] = 10;//实用下标引用操作符。
//[]的两个操作数是arr和9。
//a+b也是两个操作数

//接受一个或者多个操作数：第一个操作数是函数名，剩余的操作数就是传递给函数的参数。

//创建一个结构体类型，相当于一栋建筑的图纸
//struct Stu
//{
//	char name[20];
//	int age;
//	char id[20];
//};//分号不要忘记了
//
//int main()
//{
//	//int a = 20;
//	//使用这个类型创建了一个学生对象s1并使之初始化，相当于按照图纸赋予参数建造一栋建筑
//	struct Stu s1 = { "张三", 20, "2020092026" };
//	struct Stu *ps =&s1;
//	printf("%s\n", ps->name);
//	//结构体指针->成员名
//	//printf("%s\n", s1.name);
//	//printf("%d\n", s1.age);
//	//printf("%s\n", s1.id);
//	//结构体变量.成员名
//	return 0;
//}

//int main()
//{
//	char a = 3;//3是整型，一个4个字节，但a的数据类型为char字符，只有一个字节的空间，即8位
//	//00000000000000000000000000000011 - 3
//	//00000011 - a
//	char b = 127;
//	//00000000000000000000000001111111 - 127
//	//01111111 - b
//	//a和b怎么相加
//	//a,b都是字符数据，不到一个整型，需要整型提升
//	//整形提升是按照变量的数据类型的符号位来提升的，有符号位的char
//	//00000000000000000000000000000011 - a,符号位为0前面的位数全部补0
//	//00000000000000000000000001111111 - b,符号位为0前面的位数全部补0
//	//00000000000000000000000010000010 - 相加运算结果
//	//10000010 - c
//	char c = a + b;
//	//11111111111111111111111110000010 - c（补码），整型提升方式：符号位为1,前面的位数全部补1,补码，计算机内存中储存的是补码
//	//11111111111111111111111110000001 - c（反码），补码-1为反码
//	//10000000000000000000000001111110 - c（原码），反码取反为原码（符号位保留）
//	//11111110 - c（原码的截断结果）符号位保持为原来的1，后面7位储存数字结果，这个原码的结果是-126
//	printf("%d\n", c);//打印的是原码
//	return 0;
//}

//实例1
//int main()
//{
//	char a = 0xb6;//0x表示十六进制，十六进制转十进制转二进制：b - 11 - 1011 ; 6 - 6 - 0110;b6就是10110110，一个字节
//	short b = 0xb600;
//	int c = 0xb6000000;
//	if (a == 0xb6)//比较的时候也算一种运算，需要整型提升，而a符号为1，则网后面补1111..1111，必然与0xb6结果不等
//		printf("a");
//	if (b == 0xb600)//b同理
//		printf("b");
//	if (c == 0xb6000000)//c不用整型提升，本来就是整型
//		printf("c");//只打印c
//	return 0;
//}

//实例2
//int main()
//{
//	char c = 1;
//	printf("%u\n", sizeof(c));//1//u无符号整型
//	printf("%u\n", sizeof(+c));//4//+c进行整型运算，也会涉及整形提升
//	printf("%u\n", sizeof(-c));//4
//	printf("%u\n", sizeof(!c));//1
//	return 0;
//}
//
//int main()
//{
//	int a = 10;
//	int b = 20;
//	int c = b + a * 3;
//
//	return 0;
//}
//复杂表达式的求值有三个影响的因素。
//1. 操作符的优先级
//2. 操作符的结合性
//3. 是否控制求值顺序。如果是，则像之前那个逻辑操作符一样，后面可以确定了就不会进行后面的运算
//两个相邻的操作符先执行哪个？取决于他们的优先级。如果两者的优先级相同，取决于他们的结合性。

//int main()
//{
//	int i = 1;
//	int ret = (++i) + (++i) + (++i);//问题代码
//	printf("%d\n", ret);
//	printf("%d\n", i);
//	return 0;
//}
