#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
//C语言类型
//1、内置类型
//char 1
//short 2
//int 4
//long 4
//float 4
//double 8
//2、自定义类型（构造体）
//

//int main()
//{
//	printf("%d\n", sizeof(char));
//	printf("%d\n", sizeof(short));
//	printf("%d\n", sizeof(int));
//	printf("%d\n", sizeof(long));
//	printf("%d\n", sizeof(long long));
//	printf("%d\n", sizeof(float));
//	printf("%d\n", sizeof(double));
//	printf("%d\n", sizeof(long double));
//	return 0;
//}


//计算机中的有符号数（尤其是整数）有三种表示方法，原码，反码，补码，首位为符号位，其余为数值为。整数三码相同，负数如下
//原码，直接按照二进制翻译即可
//反码，符号位不变，其余取反
//反码加一得补码
//对整型，内存实际在存储补码
//32位二进制转为十六进制8位，直接四个二进制位为一个十六进制位，同理转为八进制也是类似
//0000 0000 0000 0000 0000 0000 0001 0100
//   0    0    0    0    0    0    1    4 -> 0x 00 00 00 14；0x表示十六进制,一共四个字节
//1111 1111 1111 1111 1111 1111 1111 0110
//0xFFFFFFF6
//在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；
//同时，加法和减法也可以统一处理（CPU只有加法器）此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。


//1-1
//1+(-1)
//补码计算
//00000000000000000000000000000001
//11111111111111111111111111111111
//100000000000000000000000000000000多一位，丢掉
//00000000000000000000000000000000
//10000000000000000000000000000000不是0，而是-2^32

//大端（存储）模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中；
//小端（存储）模式，是指数据的低位保存在内存的低地址中，而数据的高位, ，保存在内存的高地址中。
//为什么会有大小端模式之分呢？这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。


//int check_key()
//{
//	int a = 1;
//	char*p = (char*)&a;
//	return *p;
//}
//int check_key()
//{
//	int a = 1;
//	return *(char*)&a;
//}
//int main()
//{
//	int ret = check_key();
//	if (ret == 1)
//		printf("小端\n");
//	else
//		printf("大端\n");
//	return 0;
//}

//输出什么？
//#include <stdio.h>
//int main()
//{
//	char a = -1;//char也是整型，放的补码，-1的补码全是1，只不过截断成一个字节，即放进去的东西一模一样
//	signed char b = -1;//整型提升提升符号位，全补足1，ab是一回事，即11111111111111111111111111111111
//	unsigned char c = -1;//无符号整型符号位为0，补全后整型提升为00000000000000000000000011111111
//	printf("a=%d,b=%d,c=%d", a, b, c);//取的整型4个字节，要整型提升
//	return 0;
//}


//#include <stdio.h>
//int main()
//{
//	char a = -128;
//	//10000000000000000000000010000000
//	//11111111111111111111111101111111
//	//11111111111111111111111110000000
//	//10000000
//	//11111111111111111111111110000000
//	printf("%u\n", a);//u无符号4294967168
//	return 0;
//}

//#include <stdio.h>
//int main()
//{
//	char a = 128;//127+1
//	printf("%u\n", a);//u无符号4294967168
//	return 0;
//}
//int main()
//{
//	int i = -20;
//	unsigned int j = 10;
//	printf("%d\n", i + j);
//	return 0;
//}
//按照补码的形式进行运算，最后格式化成为有符号整数
//#include<Windows.h>
//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%u\n", i);
//		Sleep(100);
//	}
//	return 0;
//}

//int main()
//{
//	char a[1000];
//	int i;
//	for (i = 0; i<1000; i++)
//	{
//		a[i] = -1 - i;
//	}
//	printf("%d", strlen(a));//不是随机值
//	return 0;
//}

//#include <stdio.h>
//unsigned char i = 0;//0~255
//int main()
//{
//	for (i = 0; i <= 255; i++)//255+1=0
//	{
//		printf("hello world\n");
//	}
//	return 0;
//}


//int main()
//{
//	double d = 1E10;//1乘以10的10次方
//	printf("%lf\n", d);
//
//	return 0;
//}

//int main()
//{
//	int n = 9;
//	float *pFloat = (float *)&n;
//	printf("n的值为：%d\n", n);//9
//	printf("*pFloat的值为：%f\n", *pFloat);//0.000000
//	*pFloat = 9.0;
//	printf("num的值为：%d\n", n);//1091567616
//	printf("*pFloat的值为：%f\n", *pFloat); //9.000000
//	return 0;
//}

//根据国际标准IEEE（电气和电子工程协会） 754，任意一个二进制浮点数V可以表示成下面的形式：
//(-1) ^ S * M * 2 ^ E
//(-1) ^ s表示符号位，当s = 0，V为正数；当s = 1，V为负数。
//M表示有效数字，大于等于1，小于2。
//2 ^ E表示指数位。
//9.0
//1001.0
//(-1)^0*1.001*2^3
//S=0
//M=1.01
//E=3
//IEEE 754规定：
//对于32位的浮点数，最高的1位是符号位s，接着的8位是指数E，剩下的23位为有效数字M。
//对于64位的浮点数，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M。
//0.5十进制
//0.1二进制，2的负一次方，即十进制的0.5
//(-1)^0*1.0*2^-1
//S=0
//M=1.0
//E=-1
//E=-1+127=126

//int main()
//{
//	float f = 5.5;
//	//5.5
//	//101.1
//	//(-1)^0*1.011*2^2
//	//S=0
//	//M=1.011
//	//E=2 -> 2+127=129=10000001
//	//0 10000001 01100000000000000000000
//	//0100 0000 1011 0000 0000 0000 0000 0000
//	//0x40b00000
//	//3.14
//	//11.0011001101011101.....//人力难算
//	return 0;
//}

//指数E从内存中取出来还可以再分为3种情况
//E不全为0或不全为1
//这时，浮点数就采用下面的规则表示，即指数E的计算值减去127（或1023），得到真实值，再将有效数字M前加上第一位的1。
//比如：
//0.5（1 / 2）的二进制形式为0.1，由于规定正数部分必须为1，即将小数点右移1位，则为1.0 * 2 ^ (-1)，其阶码为 - 1 + 127 = 126，表示为
//01111110，而尾数1.0去掉整数部分为0，补齐0到23位00000000000000000000000，则其二进制表示形式为0 01111110 00000000000000000000000

//E全为0
//这时，浮点数的指数E等于1 - 127（或者1 - 1023）即为真实值，
//有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数。这样做是为了表示±0，以及接近于0的很小的数字。

//E全为1
//这时，如果有效数字M全为0，表示±无穷大（正负取决于符号位s）；

//int main()
//{
//	int n = 9;
//	//0 00000000 00000000000000000001001-补码
//	//(-1)^0*1.00000000000000000001001*2^-126
//	//约等于0
//	float *pFloat = (float *)&n;
//	printf("n的值为：%d\n", n);//9
//	printf("*pFloat的值为：%f\n", *pFloat);//0.000000整型形式放进去，浮点形式取出来
//	*pFloat = 9.0;
//	//01000001000100000000000000001001
//	printf("num的值为：%d\n", n);//1091567616浮点形式放进去，整型形式取出来
//	printf("*pFloat的值为：%f\n", *pFloat); //9.000000
//	return 0;
//}

